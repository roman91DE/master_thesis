---
title: |
  <center>Pre-Trained Denoising Autoencoders Long Short-Term Memory Networks as probabilistic Models for Estimation of Distribution Genetic Programming</center>
  <center>--------------------------------------------------------</center>
  <center>Student: Roman Höhn</center>
  <center>Date of Birth: 1991-04-14</center>
  <center>Place of Birth: Wiesbaden, Hesse</center>
  <center>Student ID: 2712497</center>
  <center>Supervisor: David Wittenberg</center>
  <center>--------------------------------------------------------</center>
  <center>Master Thesis</center>
  <center>FB 03: Chair of Business Administration and Computer Science</center>
  <center>Johannes Gutenberg University Mainz</center>
  |
date: "Date of Submission: `r Sys.Date()`"
output:
  pdf_document:
    keep_tex: true
    extra_dependencies: ["float"]
    fig_caption: yes
    number_sections: true
    includes:
      in_header: [header_files/settings.tex]
indent: false
fontsize: 11pt
bibliography: ref/ref.bib
csl: csl/association-for-computing-machinery.csl
#csl: csl/harvard-cite-them-right.csl
#csl: csl/springer-science-reviews.csl
include-before: '`\thispagestyle{empty} \newpage{}`{=latex}'
---

<!-- Python/R Setup -->

```{r setup, include=FALSE}
library(kableExtra)
library(magrittr)
library(reticulate)

EXPERIMENT_DIR<-("../eda-gp-2020/experiments")

knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.pos = "!H")


```

```{python pytest, , echo=FALSE, include=FALSE}
from sys import version, executable
print(f"Python Version: {version} \nPath: {executable}")
```



<!-- LaTeX Setup -->
\setcounter{page}{1}
\tableofcontents
\thispagestyle{empty}
\newpage  
\listoftables
\listoffigures
\thispagestyle{empty}
\newpage

<!--Markdown Text -->

# Abstract

...



# Introduction

<!--- Einführung in die Thematik -->

Denoising Autoencoder Genetic Programming (DAE-GP) is a novel variation of an genetic programming based Estimation of Distribution Algorithm (EDA-GP) that uses a denoising autoencoders long short-term memory network (DAE-LSTMs) as a probabilistic model to sample new candidate solutions [@dae-gp_2020_rtree].

DAE-LSTMs are recurrent neural networks (RNNs) that can be trained in an unsupervised learning environment to minimize a reconstruction error for encoding input data into a compressed representation and subsequently decoding the compressed representation back to the input dimension. 
In DAE-GP, DAE-LSTMs are trained with a subset of high-fitness solutions selected from a parent population with the aim to capture their promising qualities. 
The resulting model is then used to sample new offspring solutions by propagating partially mutated solutions from the parent population through the DAE-LSTMS [@dae-gp_2020_rtree].
In previous work DAE-GP has been shown to outperform GP for both a generalized version of the royal tree problem [@dae-gp_2020_rtree] as well as for a real-world symbolic regression problem [@dae-gp_2022_symreg]. 

<!--- Problemstellung und Zielsetzung der Arbeit -->

The DAE-GP algorithm first described by [@dae-gp_2020_rtree] trains a DAE-LSTMs for each generation $g$ of the search from scratch.
@dae-gp_2022_symreg and @daegp_explore_exploit suggests the incorporation of a pre-training strategy into the evolutionary search as a possible way of improving the model quality of DAE-GP.
The key idea is to pre-train an initial DAE-LSTM on a large population of candidate solutions and to use the weights of this initial model in each generation of the search as a starting point.
This thesis studies the influence of using pre-trained DAE-LSTMs in DAE-GP for symbolic regression, especially looking at the influence in generalization behavior and the overall quality of solutions found by DAE-GP. The aim of this study is to answer the question if a pre-training strategy can help to improve generalization in DAE-GP and if so, analyze how this improved generalization ability benefits the overall performance of DAE-GP.


<!--- Gang der Untersuchung -->

<!--- Describe experiments... -->
...


# Theoretical Foundations

*This section describes the relevant concepts that are necessary for the understanding and classification of DAE-GP as well as the concept of pre-training in artificial neural networks*

## Denoising Autoencoder Genetic Programming

DAE-GP is an EDA-GP algorithm that uses DAE-LSTM networks as a probabilistic model to sample new offspring solutions [@dae-gp_2020_rtree]. 

### Evolutionary Computation

As a variant of GP, DAE-GP can be classified as a meta-heuristic that belongs to the field of evolutionary computation (EC). 
EC based meta-heuristics are optimization methods that simulate the process of Darwinian evolution to search for high quality solutions by applying selection and variation operators to a population of candidate solutions. 
Examples of EC include genetic algorithms (GA), evolutionary strategies (ES) and GP. 
In EC, the quality of a solution is commonly measured as fitness and the time steps of the search are called generations. 
Another important concept in EC is the distinction between genotypes and phenotypes of solutions, the genotype contains the information that is necessary to construct the phenotype, the outer appearance of a particular solution on which we measure the overall quality of solutions. 
The representation of a solution is therefore defined by the mapping of genotypes to phenotypes [@design_of_modern_heuristics]. 
Genetic operators, such as mutation or recombination are usually applied to the genotype of solutions.

### Genetic Programming

GP follows the same basic evolutionary principle of EC but searches for more general, hierarchical computer programs of dynamically varying size and shape [@Koza1993GeneticP]. 
The computer programs that are at the center of the evolutionary search in GP are commonly represented by tree structures at the level of their phenotype [@design_of_modern_heuristics]. 
Since GP searches for high fitness computer programs that produce a desired output for some input, it can be applied to various different problem domains such as symbolic regression, automatic programming, or evolving game-playing strategies [@Koza1993GeneticP]. 
An important quality of GP is the ability to search for solutions of variable length and structure. 
GP is an especially useful meta heuristic for problems where no a priori knowledge about the final form of good solutions is available.
GPs ability to optimize solutions for their structure as well as for their parameters led to it being one of the most prevalent methods used symbolic regression [@10.1007/978-3-540-24621-3_22].

### Estimation of Distribution Algorithms

The aim of Estimation of distribution algorithms (EDA) is to replace the standard variation operators used in GA by building probabilistic models that can capture complex dependencies between different decision variables of an optimization problem [@design_of_modern_heuristics]. 
EDAs use this probabilistic model to sample new offspring solutions inside an evolutionary search to replace crossover and/or mutation operators. 

### Denoising Autoencoders

One possible way of model building in EDA proposed by @harmless_overfitting_eda is to use denoising autoencoders (DAEs) as generative models to capture complex probability distributions of decision variables. 

DAE, a variation of the autoencoders (AE), are a widely used type of neural networks in the domain of unsupervized machine learning that maps $n$ input variables to $n$ output variables using a hidden representation.

AE were introduced by @ae_orig to compress high-dimensional data into lower-dimensions. An AE consists of two different subunits:

  * Encoder $g(x)$: Encode input data to a smaller cental layer $h$
  * Decoder $d(h)$: Decode and output the the encoded data back to its original dimension
  
The AE is trained to reduce the reconstruction error between input and output data, after the training procedure is finished the network is able to reduce the dimensionality of input data to a compressed representation[@ae_orig].


DAE was first introduced by @10.1145/1390156.1390294 as an improved AE with the ability to learn new representations of data that is especially robust to partially corrupted input data. DAE modifies the AE by using partially corrupted input data for the AE and training it to reconstruct the uncorrupted, original version of the input data.

Since the hidden representation of DAE captures the dependency structure of the input data it can therefore also be used to generate new solutions in the context of GAs [@harmless_overfitting_eda].

DAE-GP builds upon the concept of using DAEs in EDAs described by @harmless_overfitting_eda and transfers the concept to the domain of GP. 
The mutation and crossover operators of standard GP are replaced by sampling new solutions from a probabilistic model that is build by training a DAEs long short-term memory (LSTM) network on a subset of high fitness solutions from the current population [@dae-gp_2020_rtree]. 
LSTMs are a variant of recurrent neural networks first introduced by @lstm_orig that can store learned information over en extended time period while avoiding the problem of vanishing and/or exploding gradients. Since DAE-GP encodes candidate solutions as linear strings in prefix notation, the DAE in DAE-GP uses LSTMs for both encoding and decoding where the total amount of time steps $T$ is equal to sum of the length of the input solution and the output solution [@dae-gp_2020_rtree].


## Pre-Training

<!--- 
chatGPT
---

Q: what is pre-training in deep learning?
A: Pre-training in deep learning refers to the process of training a deep learning model on a large dataset before using it for a specific task. The goal of pre-training is to create a model that has a strong general understanding of the data and can be fine-tuned for a specific task.

Pre-training can be done in two ways: unsupervised pre-training and supervised pre-training. In unsupervised pre-training, the model is trained on a large dataset without labels, using techniques such as self-supervised learning or generative adversarial networks (GANs) to learn the underlying patterns in the data. In supervised pre-training, the model is trained on a large dataset with labels, using a supervised learning algorithm to learn the relationship between the input data and the corresponding labels.

Pre-training has several benefits. It can help improve the performance of the model on the target task by providing it with a better initial set of weights. It can also speed up training by reducing the amount of data and computational resources needed to train the model from scratch. Additionally, pre-trained models can be used as a starting point for transfer learning, allowing you to leverage the knowledge and experience of the pre-trained model for a new task.

Overall, pre-training is an important technique in deep learning that can help improve model performance and efficiency. It is commonly used in natural language processing and computer vision applications, where large amounts of labeled data are available.
-->

The strategy of pre-training artificial neural networks is based on the idea of transfer learning. 
Transfer learning in the field of machine learning aims at retaining previously learned knowledge from one task to re-use it for another task [@HAN2021225] [@survey_transfer_learning]. Transfer learning traditionally follows a two phase approach:

1. Pre-Training Phase: Capture knowledge from source task
2. Fine-Tuning Phase: Transfer knowledge to the target task

where source task and target task are usually similar but may differ in their feature space and the distribution of training data [@survey_transfer_learning].
One of the main motivations for using transfer learning in real world machine learning tasks is the ability to reduce the need for large amounts of training data which can often be unavailable or too expensive to collect.

Pre-Training is a commonly used strategy in deep architectures that has been shown to improve both the optimization process itself as well as the generalization behavior if compared to randomly initialized parameters [@pmlr-v5-erhan09a].

...describe different pre-training strategies, e.g. few shot, perpetual, re-using...

-- describe unsupervized vs supervized pre-training...



# Pre-Training in DAE-GP

The pre-training strategy used in this thesis is applied to the DAE-LSTM model $M_g$ that are used in each DAE-GP generation $g$ for $g\in{1,...,g_{max}}$. 
Instead of initializing and optimizing each model from scratch as done in previous work (e.g. [@dae-gp_2020_rtree] [@dae-gp_2022_symreg]), a separate DAE-LSTM network $\hat{M}$ will be trained on a large population of randomly initialized solutions.  
The optimal parameters obtained after finishing the training procedure of $\hat{M}$ are then used as the starting parameters for each following DAE-LSTM model $M_g$ for $g\in{1,...,g_{max}}$.

The motivation for incorporating pre-training into DAE-GP is based on the following suspected mechanisms of improvement:

1. Improve overall performance of DAE-GP by improving either run time and/or solution quality
2. Reduce the need for large population sizes to avoid sampling error
3. Improve model robustness and generalization ability

The probably most obvious motivation for using a pre-training strategy in DAE-GP is based on the fact, that initializing $M_g$ with pre-trained weights from $\hat{M}$ is likely to reduce the amount of training epochs that are necessary until the point of training error convergence is reached. 

Early research on pre-training for DAE by @pmlr-v5-erhan09a comes to the conclusion that besides adding robustness to models the strategy also results in improved generalization and better performing models. The authors describe that unsupervised pre-training behaves like a regulizer on DAE networks, the mean test error and it's variance are reduced for DAE networks that are initialized from pre-trained weights if compared to the same architectures that use random initialization.

Another important finding by @pmlr-v5-erhan09a is that the positive effect of pre-training described above is dependent on both the depth of the network as well as the size of layers - while increasingly larger networks benefit increasingly more from pre-training the final performance of small architectures tends to be worse with pre-training than with randomized weight initialization. The authors find evidence that pre-training DAE is especially usefull for optimizing the parameters of the lower layers of the network. 

Another motivation for introducing pre-training into DAE-GP is the prevalence of sampling error for small GP populations sizes.
[@sampling_err_gp] finds that sampling error, non-systematic errors that are caused by observing only a small subset of the statistical population, is a severe problem in the domain of GP since the initial population may not be a representative sample of all possible solutions.
[@sampling_err_gp] also introduces a method for calculating optimal population sizes to minimize the presence of sampling error.
Since DAE-LSTM of DAE-GP learns the properties of it's training population and reuses the acquired knowledge in the sampling procedure, using the parameters obtained from training $\hat{M}$ on a sufficiently large training population might reduce the need for large population sizes in the following generations of the search if $\hat{M}$ already implicitly captured the properties of a representative sample of solutions.
If this mechanism can be applied successfully it would benefit the performance of DAE-GP by increasing the population diversity (resulting in better solution quality) as well as by reducing the need for large population sizes which require computational resources. 


## Implementation

<!--- Explain algorithm and pre-training strategy in pseudo code -->

The DAE-GP algorithm, first described by @dae-gp_2020_rtree, is described by algorithm 1 

```{.numberLines}
WHILE NOT termination_criterion
  DO 
END WHILE
RETURN
```

One difficulty in the implementation of a pre-training strategy into DAE-GP has been the detemination of the number of hidden neurons in side the DAE-LSTMs hidden layers. The original description of DAE-GP [@dae-gp_2020_rtree] used a strategy where the number of hidden neurons for each hidden layer is dynamically set per generation to the maximum individual size inside the current population.
For a pre-training implementation, this strategy can not be easily adapted since it leads to a changing number of neurons at each generation resulting in different dimensions of the DAE-LSTM. To allow for the sharing of weights and biases from the pre-trained model $\hat{M}$ to each $M_g$ for $g\in{1,...,g_{max}}$ I experimented with two different strategies:

1. Set the number of hidden neurons per hidden layer for each generation to the maximum individual size inside the pre-training population
2. (dependent on the terminal/function set)

The framework that was used to conduct all experiments of this thesis was provided by the supervisor David Wittenberg and uses the python programming language in conjunction with the baseline libraries `Keras` [@chollet2015keras] for deep neural networks and `deap` [@DEAP_JMLR2012] for evolutionary computation.


## Benchmark Problem

<!--- Symbolic regression -->
To test pre-training in DAE-GP this thesis focuses on the domain of real-world symbolic regression problems. Symbolic Regression problems have been one of the first GP applications [@Koza1993GeneticP] and are an actively studied and highly relevant research area. The goal in symbolic regression is to find a mathematical model for a given set of data points [@10.1007/978-3-540-24621-3_22], in real-world symbolic regression these data points are sourced from real-world observations which in contrast to synthetic symbolic regression problem are more likely to contain random noise and bias. Another important challenge in solving real-world symbolic regression problems is the ability for a given model to generalize, we want the final model to show high accuracy in predicting outcomes for previously unseen cases.

<!--- airfoil dataset -->
The main experiments conducted in this thesis uses the NASA Airfoil Self-Noise Data Set which is part of the UCI machine learning repository [@machine_learning_repo]. The dataset consists of 5 input variables and 1 output variable that are listed in table 1.

```{r airfoil_dataset_description, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}
fig.pos="H"
knitr::kable(
  read.csv("./tables/airfoil_vars.csv"),
  caption="Airfoil - Dataset Description"
)%>% row_spec(0,bold=TRUE ) %>% kableExtra::kable_styling(latex_options = "hold_position")
```

The objective of the airfoil problem is to find a function that accurately predicts the output variable $y$ by taking in a subset of the input variables $x1,x2,x3,x4,x5$. The function set used by all DAE-GP variations for the airfoil problem is summarized in table 2, the terminal set consists of the 5 input variables $x1,x2,x3,x4,x5$ and ephemeral random integers in the range of $[{}-5,..,5]$ [@dae-gp_2022_symreg].

```{r airfoil_function_set, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}
fig.pos="H"
knitr::kable(
  read.csv("./tables/airfoil_function_set"),
  caption="Airfoil - Function Set"
)%>% row_spec(0,bold=TRUE ) %>% kableExtra::kable_styling(latex_options = "hold_position")
```


<!--- energy heating dataset -->

# Results


## Exploratory Phase

In a first exploratory experiment DAE-GP was tested on the Aifoil dataset to perform a symbolic regression task. The aim of this initial experiment is to search for differences in behavior between an algorithm that uses a pre-training strategy and regular DAE-GP. The parameters for the experiment are summarized in table 2, the average results for fitness, number of fitness evaluations, average tree size of the population and the unique rate of the population are summarized in plot 1.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}
fig.pos="H"
knitr::kable(
  read.csv("/Users/rmn/masterThesis/eda-gp-2020/experiments/airfoil_ptdaegp-daegp_rwsr_1hl/parameters.csv"),
  digits=3,
  caption="Airfoil - Configuration"
)%>% row_spec(0,bold=TRUE ) %>% kableExtra::kable_styling(latex_options = "hold_position")
```

![Airfoil - First Results](./img/airfoil_exploratory/airfoil_exploratory.png)

In this first experiment, the average quality of solutions produced by the pre-trained algorithm shows to be lower than that produced by regular DAE-GP. Differences in fitness start to show at generation 5 where regular DAE-GP starts to reduces RMSE more efficiently than the pre-trained version. The gap in average fitness grows larger until the end of the evolutionary search between both algorithms. Observing the gap between RMSE on the training dataset and the testing dataset shows no major differences, the training error is slightly lower than the testing error for both algorithms and indicates a similar generalization behavior.

Another interesting metric to investigate is the population's average tree size, in general smaller solutions are preferable to their larger counterparts because of improved interpretability. The results show, that average tree size is reduced strongly in generations 1-5 for both algorithms and than slowly increases back. Differences between regular DAE-GP and the pre-trained DAE-GP start to show at generation 2, where the average population tree size is continuously lower for regular DAE-GP.

It can also be observed that the population diversity, measured by the normalized levenshtein distance, is different between both DAE-GP variants. Both algorithms start at a unique rate of about 0.8 in the 0.th generation and lower rapidly to an average of about 0.45 in the 7.th generation. In the following generations, the diversity of pre-trained DAE-GP keeps lowering steadily while regular DAE-GP slowly increases the population diversity to a normalized levenshtein distance of about 0.55. This could be a first explanation for the better performance of regular DAE-GP in this experiment, by creating more diverse populations over the later generations of the search the algorithm is better at exploiting the search space than the pre-trained DAE-GP algorithm.


## Effect on Generalisation

To gather a deeper understanding about the effect of pre-training DAE-LSTM in DAE-GP a series of experiments was conducted, again using the airfoil dataset for symbolic regression, and different parameter configurations for the number of hidden layers as well as the number of hidden neurons per hidden layer.

To study generalization behavior this series of experiments is conducted using DAE-GP with only a single generation until the search terminates. I disregard the fitness of solutions found and focus soley on the reconstruction error that is produced during the training of each the DAE-LSTM. The reconstruction error is measured for two separate populations, a training population $train\_pop$ that is used to train our DAE-LSTM as well as a hold-out validation population $test\_pop$. For the pre-trained DAE-GP two additional, separate populations $\hat{train\_pop}$ and  $\hat{test\_pop}$ are used only for pre-training. 

DAE-GP is tested in two different configurations: 

* Variable number of hidden neurons (50, 100, 200) with a single hidden layer
* Fixed number of hidden neurons (100) per hidden layer with variable number of hidden layers (1, 2, 3)

For each configuration I tested traditional DAE-GP as well as a pre-trained DAE-GP resulting in 12 total sub experiments that were each based on 10 individual runs (total number of runs=$120$). To avoid creating biased results through the presence of sampling error inside the pre-training population (see @sampling_err_gp), the population size for the pre-training phase is chosen very high with $\hat{pop\_size}=20000$ where 50% of $\hat{pop}$ is used for the training population $\hat{train\_pop}$ and the remaining 50% are used for the hold-out validation population $\hat{test\_pop}$. The training of DAE-LSTM uses a fixed number of 1000 epochs until termination and uses Adam optimization for gradient descent. The reason for using a high amount of 1000 fixed training epochs is to deliberately force the DAE-LSTM to overfit to the training data. 

In general I expect that with a growing number of model parameters (either by adding more hidden layers or more hidden neurons per layer) the DAE-LSTM will be more prone to overfit to the training population $train\_pop$ resulting in a small reconstruction error for the training population and a large one for the validation population $train\_pop$. The reason for this effect is that a larger network trained over an extended period of time (without the use of strategies like early stopping), has much more potential to learn noise from the training dataset than a smaller network, which is more likely to result in worsening performance for previously unseen cases [@weigend1994overfitting].

Based on the review of [@pmlr-v5-erhan09a] I also expect that pre-training will have an insignificant or even negative influence on small DAE-LSTM instances while improving the networks generalization ability with growing size.

<!--- analyze results 1 hidden layer and variable number of hidden neurons -->



![Airfoil - First Generation Median Training Error for variable number of hidden Neurons](./img/airfoil_firstGen/airfoil_firstGen_median_training_error_by_neurons.png)

![Airfoil - First Generation final Training Error for variable number of hidden Neurons](./img/airfoil_firstGen/airfoil_firstGen_boxplot_training_error_by_neurons.png)

<!--- analyzing by layers -->

# Discussion

...




# Limitations and open Questions

## Further Questions

[@pmlr-v5-erhan09a]: Pre-Training effect especially usefull for lower-level layers -> Only adapt weights from low layers or embedd the pre-trained model?

Different pre-training strategies?


\newpage  

# References {.unnumbered #I}

::: {#refs}
:::


<!--
  EIDESSTAATLICHE ERKLAERUNG
# II - Statutory Declaration {.unnumbered #II}

![Statutory Declaration](./private/erklaerung.pdf)\

-->

